From 866522f419dac930e15b715decca2c6b4c102f6d Mon Sep 17 00:00:00 2001
From: Leon Kessler <leon.kessler@digital.justice.gov.uk>
Date: Tue, 22 Feb 2022 13:06:23 +0000
Subject: [PATCH] Issue #3265853: Support other modules that provide their own
 field widget plugins (e.g. Select2)

---
 .../OptGroupEntityReferenceSelection.php      | 87 +++++++++++++++++++
 1 file changed, 87 insertions(+)
 create mode 100644 src/Plugin/EntityReferenceSelection/OptGroupEntityReferenceSelection.php

diff --git a/src/Plugin/EntityReferenceSelection/OptGroupEntityReferenceSelection.php b/src/Plugin/EntityReferenceSelection/OptGroupEntityReferenceSelection.php
new file mode 100644
index 0000000..5a94888
--- /dev/null
+++ b/src/Plugin/EntityReferenceSelection/OptGroupEntityReferenceSelection.php
@@ -0,0 +1,87 @@
+<?php
+
+namespace Drupal\optgroup_taxonomy_select\Plugin\EntityReferenceSelection;
+
+use Drupal\Component\Utility\Html;
+use Drupal\Core\Form\FormStateInterface;
+use Drupal\taxonomy\Entity\Vocabulary;
+use Drupal\taxonomy\Plugin\EntityReferenceSelection\TermSelection;
+
+/**
+ * Plugin implementation of the 'optgroup_taxonomy_select' entity_reference.
+ *
+ * @EntityReferenceSelection(
+ *   id = "optgroup_taxonomy_select",
+ *   label = @Translation("OptGroup Taxonomy Select"),
+ *   entity_types = {"taxonomy_term"},
+ *   group = "optgroup_taxonomy_select",
+ *   weight = 0
+ * )
+ */
+class OptGroupEntityReferenceSelection extends TermSelection {
+
+  /**
+   * {@inheritdoc}
+   */
+  public function buildConfigurationForm(array $form, FormStateInterface $form_state) {
+    $form = parent::buildConfigurationForm($form, $form_state);
+
+    // We (currently) only support one vocabulary at a time, so convert the
+    // checkboxes to radios.
+    $form['target_bundles']['#type'] = 'radios';
+
+    // Target bundle is stored as an array, but radios element expects a string.
+    $form['target_bundles']['#default_value'] = reset($form['target_bundles']['#default_value']);
+    return $form;
+
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public static function elementValidateFilter(&$element, FormStateInterface $form_state) {
+    // Convert submitted value to array.
+    $element['#value'] = [$element['#value']];
+    $form_state->setValueForElement($element, $element['#value']);
+  }
+
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getReferenceableEntities($match = NULL, $match_operator = 'CONTAINS', $limit = 0) {
+    if ($match || $limit) {
+      return parent::getReferenceableEntities($match, $match_operator, $limit);
+    }
+
+    $options = [];
+
+    $bundles = $this->entityTypeBundleInfo->getBundleInfo('taxonomy_term');
+    $bundle_names = $this->getConfiguration()['target_bundles'] ?: array_keys($bundles);
+
+    $has_admin_access = $this->currentUser->hasPermission('administer taxonomy');
+    $unpublished_terms = [];
+    foreach ($bundle_names as $bundle) {
+      if ($vocabulary = Vocabulary::load($bundle)) {
+        /** @var \Drupal\taxonomy\TermInterface[] $terms */
+        if ($terms = $this->entityTypeManager->getStorage('taxonomy_term')->loadTree($vocabulary->id(), 0, NULL, TRUE)) {
+          foreach ($terms as $term) {
+            if (!$has_admin_access && (!$term->isPublished() || in_array($term->parent->target_id, $unpublished_terms))) {
+              $unpublished_terms[] = $term->id();
+              continue;
+            }
+            $label = Html::escape($this->entityRepository->getTranslationFromContext($term)->label());
+            if ($term->depth === 0) {
+              $parent = $label;
+            }
+            else {
+              $options[$vocabulary->id()][$parent][$term->id()] = str_repeat('-', $term->depth - 1) . $label;
+            }
+          }
+        }
+      }
+    }
+
+    return $options;
+  }
+}
--
GitLab
